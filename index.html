<html>
<title>HexaWeb</title>
<style>

#board
{
	display: block;
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
}

.piece
{

}

.piece-background 
{
	fill: #eee;
/* 
	-webkit-transition: stroke .2s;
    transition: stroke .2s;
*/
}

.piece-path
{
	stroke-width:.05px;
	stroke: #000;
	fill: #aaa;
}

/* 
.piece.satisfied .piece-background
{
	stroke: #ada;
	-webkit-transition: stroke .2s;
    transition: stroke .2s;
}
*/
</style>
<body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var pieceSignature = [
	[false, false, false, false, false, false], // 0
	[ true, false, false, false, false, false], // 1
	[ true,  true, false, false, false, false], // 2
	[ true, false,  true, false, false, false], // 3
	[ true, false, false,  true, false, false], // 4
	[ true,  true,  true, false, false, false], // 5
	[ true,  true, false,  true, false, false], // 6
	[ true,  true, false, false,  true, false], // 7
	[ true, false,  true, false,  true, false], // 8
	[ true,  true,  true,  true, false, false], // 9
	[ true,  true,  true, false,  true, false], // 10
	[ true,  true, false,  true,  true, false], // 11
	[ true,  true,  true,  true,  true, false], // 12
	[ true,  true,  true,  true,  true,  true], // 13
];

// all-piece demo
var pieces = [
	{r:-2, q:0, type:1, offset:0},
	{r:-2, q:1, type:6, offset:3},
	{r:-2, q:2, type:3, offset:3},
	{r:-1, q:-1, type:2, offset:1},
	{r:-1, q:0, type:8, offset:1},
	{r:-1, q:1, type:1, offset:2},
	{r:-1, q:2, type:7, offset:2},
	{r:0, q:-2, type:1, offset:1},
	{r:0, q:-1, type:10, offset:2},
	{r:0, q:0, type:12, offset:0},
	{r:0, q:1, type:11, offset:0},
	{r:0, q:2, type:5, offset:4},
	{r:1, q:-2, type:9, offset:1},
	{r:1, q:-1, type:13, offset:0},
	{r:1, q:0, type:8, offset:1},
	{r:1, q:1, type:4, offset:5},
	{r:2, q:-2, type:2, offset:5},
	{r:2, q:-1, type:3, offset:0},
	{r:2, q:0, type:5, offset:5},
];

/*
// harder!
pieces = [ 
	{r:-2, q:0, type:1, offset:0},
	{r:-2, q:1, type:5, offset:3},
	{r:-2, q:2, type:2, offset:2},
	{r:-1, q:-1, type:5, offset:2},
	{r:-1, q:0, type:3, offset:5},
	{r:-1, q:1, type:2, offset:5},
	{r:-1, q:2, type:3, offset:4},
	{r:0, q:-2, type:1, offset:5},
	{r:0, q:-1, type:10, offset:2},
	{r:0, q:0, type:7, offset:1},
	{r:0, q:1, type:11, offset:0},
	{r:0, q:2, type:2, offset:3},
	{r:1, q:-2, type:5, offset:1},
	{r:1, q:-1, type:12, offset:4},
	{r:1, q:0, type:10, offset:5},
	{r:1, q:1, type:1, offset:5},
	{r:2, q:-2, type:2, offset:5},
	{r:2, q:-1, type:3, offset:0},
	{r:2, q:0, type:2, offset:4},
];
*/

/*
// cute
pieces = [
	{r:-2, q:0, type:1, offset:1}, 
	{r:-2, q:1, type:3, offset:2}, 
	{r:-2, q:2, type:3, offset:3}, 
	{r:-1, q:-1, type:2, offset:2}, 
	{r:-1, q:0, type:11, offset:2}, 
	{r:-1, q:1, type:1, offset:2}, 
	{r:-1, q:2, type:7, offset:2}, 
	{r:0, q:-2, type:5, offset:1}, 
	{r:0, q:-1, type:12, offset:5}, 
	{r:0, q:0, type:5, offset:0}, 
	{r:0, q:1, type:6, offset:0}, 
	{r:0, q:2, type:2, offset:4}, 
	{r:1, q:-2, type:5, offset:0}, 
	{r:1, q:-1, type:10, offset:4}, 
	{r:1, q:0, type:7, offset:1}, 
	{r:1, q:1, type:2, offset:3}, 
	{r:2, q:-2, type:2, offset:0}, 
	{r:2, q:-1, type:4, offset:0}, 
	{r:2, q:0, type:5, offset:5};
];
*/

var width = 11,
	height = 10;
var board = d3.select("body")
	.append("svg")
	.attr("id", "board")
	.attr("viewBox", "" + (-width/2) + "," + (-height/2) + "," + width + "," + height)
	.on("click", function() {newPieceAt(d3.event)});
//	.attr("preserveAspectRatio", "xMidYMid meet");
updateDrawnPieces();

function updateDrawnPieces()
{
	board.selectAll(".piece")
		.data(pieces)
		.enter()
		.append("g")
		.classed("piece", true)
		.each(createPiece);
	//board.selectAll(".piece").classed("satisfied", isSatisfied);
	board.selectAll(".piece").call(d3.drag()
		.on("start", dragstarted)
		.on("drag", dragged)
		.on("end", dragended));
}

function dist(c1, c2) { return Math.sqrt((c1.x-c2.x)**2 + (c1.y-c2.y)**2); }

function dragstarted(d)
{
}

var pt = document.getElementById("board").createSVGPoint(); // Created once for document

function scaleCoords(evt)
{
	pt.x = evt.clientX;
	pt.y = evt.clientY;
	
	// The cursor point, translated into svg coordinates
	return pt.matrixTransform(document.getElementById("board").getScreenCTM().inverse());
}

function dragged(data)
{
	d3.selectAll(".piece").select(".piece-path").attr("d", function(d) {return pathSpecification(d);});
	var center = p2c(2*data.q, 0, 2*data.r, -60);
	if (dist(center, d3.event) >= 1)
	{
		
		var angle = (180/Math.PI*Math.atan2(center.y-d3.event.y, d3.event.x-center.x)+360)%360;
		d3.select(this).select(".piece-path").attr("d", function(d) {return pathSpecification(d, angle);});
		var endpoint = p2c(center.x, center.y, 1, angle);
		
		var nbrs = nbrsOf(data);
		for (var i = 0; i<6; i++)
		{
			nbr = nbrs[i];
			var nbrcenter = p2c(2*nbr.q, 0, 2*nbr.r, -60);
			if (dist(nbrcenter, d3.event) <= 1)
			{
				var nbrselection = board.select(id(nbr));
				if (!nbrselection.empty())
				{
					var nbrdata = nbrselection.datum();
					var angle2 = (180/Math.PI*Math.atan2(nbrcenter.y-endpoint.y, endpoint.x-nbrcenter.x)+360)%360;
					nbrselection.select(".piece-path").attr("d", function(d) {return pathSpecification(d, angle2);});
				}
				break;
			}
		}
	}
}

function dragended(data)
{
	var nbrs = nbrsOf(data);
	var valid = false;
	var i, nbr, nbrdata, nbrselection;
	for (i = 0; i<6; i++)
	{
		nbr = nbrs[i];
		var center = p2c(2*nbr.q, 0, 2*nbr.r, -60);
		if (dist(center, d3.event) <= 1)
		{
			nbrselection = board.select(id(nbr));
			if (!nbrselection.empty())
			{
				nbrdata = nbrselection.datum();
				valid = true;
			}
			break;
		}
	}
	if (valid)
	{
		var sig = pieceSignature[data.type];
		var newsig = []
		for (var j = 0; j<6; j++)
			newsig.push(sig[(j+data.offset)%6]);
		var createEdge = newsig[i] = !newsig[i];
		findType(data, newsig);
		
		sig = pieceSignature[nbrdata.type];
		newsig = []
		for (var j = 0; j<6; j++)
			newsig.push(sig[(j+nbrdata.offset)%6]);
		newsig[(i+3)%6] = createEdge;
		findType(nbrdata, newsig);
		
		nbrselection.select(".piece-path").attr("d", function(d) {return pathSpecification(d);});
		nbrselection.select(".piece-inner").attr("transform", "rotate("+(nbrdata.offset*60)+")");
	}
	
	d3.select(this).select(".piece-path").attr("d", function(d) {return pathSpecification(d);});
	d3.select(this).select(".piece-inner").attr("transform", "rotate("+(data.offset*60)+")");
}

function findType(d, signature)
{
	for (var type = 0; type < pieceSignature.length; type++)
	{
		var testsig = pieceSignature[type];
		for (var offset = 0; offset < 6; offset++)
		{
			var success = true;
			for (var i = 0; i<6; i++)
			{
				if (signature[i] != testsig[(i+offset)%6])
				{
					success = false;
					break;
				}
			}
			if (success)
			{
				d.type = type;
				d.offset = offset;
				return;
			}
		}
	}
}

function scramble()
{
	for (data of pieces)
	{
		data.offset = Math.floor(6*Math.random());
	}
	// FIX ME: If you are going to call it again, make it a function!
	board.selectAll(".piece-inner")
		.transition()
		.attr("transform", function(d) { return "rotate("+(d.offset*60)+")";} )
		.duration(function() { return 200+50*Math.floor(7*Math.random()); });
// 		.on("end", function(d) { board.selectAll(".piece").classed("satisfied", isSatisfied); });
}

function rawid(coord) { return  "r"+coord.r+"q"+coord.q; }
function id(coord)    { return "#r"+coord.r+"q"+coord.q; }

function pathSpecification(d, angle = -1)
{
	var sig = pieceSignature[d.type];
	var pathSpec = "";
	if (d.type == 1 && angle < 0)
	{
		pathSpec = "M"+p2cstring(0,0,1,0) + " L "+p2cstring(0,0,.2,0)+" A .2,.2 0 1 1"+p2cstring(0,0,.2,1);
	}
	else if (d.type == 0 && angle >= 0)
	{
		pathSpec = "M"+p2cstring(0,0,1,angle+60*d.offset) + " L "+p2cstring(0,0,.2,angle+60*d.offset)+" A .2,.2 0 1 1"+p2cstring(0,0,.2,angle+60*d.offset+1);
	}
	else if (d.type != 0 || angle >= 0)
	{
		pathSpec = "M";
		for (var i = 0; i<6; i++)
		{
			if (sig[i])
				pathSpec += p2cstring(0,0,1,i*60) + " Q 0,0";
			if (angle >= 0 && 60*i < (angle+60*d.offset)%360 && (angle+60*d.offset)%360 < 60*(i+1))
				pathSpec += p2cstring(0,0,1,angle+60*d.offset) + " Q 0,0";
		}
		pathSpec += p2cstring(0,0,1,0);
	}
	return pathSpec;
}

function createPiece(d)
{
	var piece = d3.select(this)
		.attr("id", rawid(d))
		.attr("transform", "translate("+p2cstring(2*d.q, 0, 2*d.r, -60)+")")
		.append("g")
		.classed("piece-inner", true)
		.attr("transform", "rotate("+(d.offset*60)+")")
		.on("click", rotate)
		.on("touchend", rotate);
	piece.append("circle")
		.classed("piece-background", true)
		.attr("cx", "0")
		.attr("cy", "0")
		.attr("r", "1");
	var path = piece.append("path")
		.classed("piece-path", true)
		.attr("d", function(d) {return pathSpecification(d);});
}

// expects an object with row and column entries r and q
// returns a list of neighboring coordinates
function nbrsOf(coord)
{
	var r = coord.r, q = coord.q;
	return [
		{r:r, q:q+1},
		{r:r-1, q:q+1},
		{r:r-1, q:q},
		{r:r, q:q-1},
		{r:r+1, q:q-1},
		{r:r+1, q:q},
	];
}

function isSatisfied(d)
{
	var nbrs = nbrsOf(d);
	var sig = pieceSignature[d.type];
	for (var i = 0; i < 6; i++)
	{
		var hasEdge = sig[(i+d.offset)%6];
		if (hasEdge)
		{
			var nbr = nbrs[i];
			var nbrnode = document.getElementById(rawid(nbr));
			if (nbrnode == null)
				return false;
			var nbrdata = nbrnode.__data__;
			var nbrsig = pieceSignature[nbrdata.type];
			var hasMatchingEdge = nbrsig[(i+3+nbrdata.offset)%6];
			if (!hasMatchingEdge)
				return false;
		}
	}
	return true;
}

function rotate(d)
{
	if (d3.event.shiftKey)
		d.offset = (d.offset+5)%6;
	else
		d.offset = (d.offset+1)%6;
	d3.select(this)
		.transition()
		.attr("transform", "rotate("+(d.offset*60)+")")
		.duration(250);
// 		.on("end", function(d) { board.selectAll(".piece").classed("satisfied", isSatisfied); });
	d3.event.preventDefault();
	d3.event.stopPropagation();
}

function newPieceAt(xycoord)
{
	var scaledCoord = scaleCoords(xycoord);
	var data = coord2hex(scaledCoord);
	data.type = data.offset = 0;
	pieces.push(data);
	updateDrawnPieces();
}

// Convert polar coordinates to Cartesian
function p2c(cx, cy, r, deg)
{
	var rad = deg * Math.PI / 180.0;
	return { x: cx + (r * Math.cos(rad)), y: cy - (r * Math.sin(rad)) };
}

function p2cstring(cx, cy, r, deg)
{
	coord = p2c(cx, cy, r, deg);
	return " " + coord.x + "," + coord.y;
}

function coord2hex(xycoord)
{
	var x = (xycoord.x * Math.sqrt(3)/3 - xycoord.y/3)/(2/Math.sqrt(3));
	var z = (xycoord.y * 2/3)/(2/Math.sqrt(3));
	var y = -x-z;
	return hexRound(x,y,z);
}

function hexRound(x,y,z)
{
    var rx = Math.round(x);
    var ry = Math.round(y);
    var rz = Math.round(z);

    var dx = Math.abs(rx - x);
    var dy = Math.abs(ry - y);
    var dz = Math.abs(rz - z);

    if (dx > dy && dx > dz)
        rx = -ry-rz;
    else if (dy > dz)
        ry = -rx-rz;
    else
        rz = -rx-ry;

    return {q: rx, r: rz};
}

</script>

</body>
</html>